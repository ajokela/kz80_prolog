//! Bytecode compiler for Prolog clauses.
//!
//! Compiles Prolog AST to SPM bytecode following WAM-style compilation.

use std::collections::HashMap;

use crate::analyze::{analyze_clause, ClauseAnalysis, VarClass};
use crate::ast::{ArithExpr, ArithOp, Clause, CompareOp, Goal, PredicateKey, Program, Term};
use crate::runtime::opcodes;
use crate::symbol::{AtomTable, SymbolTable};

/// Compiled bytecode for a program.
#[derive(Debug)]
pub struct CompiledProgram {
    /// Bytecode for all clauses
    pub code: Vec<u8>,
    /// Entry points for each predicate (name/arity -> offset)
    pub predicates: HashMap<PredicateKey, u16>,
    /// Query entry point (if present)
    pub query_offset: Option<u16>,
    /// Atom table
    pub atoms: AtomTable,
}

/// Compiler state.
pub struct Compiler {
    /// Generated bytecode
    code: Vec<u8>,
    /// Label addresses
    labels: HashMap<String, u16>,
    /// Pending fixups (offset, label)
    fixups: Vec<(usize, String)>,
    /// Symbol table
    symbols: SymbolTable,
    /// Next label ID
    label_counter: usize,
}

impl Compiler {
    /// Create a new compiler.
    pub fn new(symbols: SymbolTable) -> Self {
        Self {
            code: Vec::new(),
            labels: HashMap::new(),
            fixups: Vec::new(),
            symbols,
            label_counter: 0,
        }
    }

    /// Compile a program.
    pub fn compile(mut self, program: &Program) -> CompiledProgram {
        let mut predicates = HashMap::new();

        // Group clauses by predicate
        let mut clause_groups: HashMap<PredicateKey, Vec<&Clause>> = HashMap::new();
        for clause in &program.clauses {
            let key = PredicateKey::new(
                clause.predicate_key().0,
                clause.predicate_key().1,
            );
            clause_groups.entry(key).or_default().push(clause);
        }

        // Compile each predicate
        for (key, clauses) in &clause_groups {
            let offset = self.code.len() as u16;
            predicates.insert(key.clone(), offset);
            self.compile_predicate(key, clauses);
        }

        // Compile query if present
        let query_offset = if let Some(goals) = &program.query {
            let offset = self.code.len() as u16;
            self.compile_query(goals);
            Some(offset)
        } else {
            None
        };

        // Resolve label fixups
        self.resolve_fixups();

        CompiledProgram {
            code: self.code,
            predicates,
            query_offset,
            atoms: self.symbols.atoms,
        }
    }

    /// Generate a unique label.
    fn gen_label(&mut self, prefix: &str) -> String {
        let label = format!("{}_{}", prefix, self.label_counter);
        self.label_counter += 1;
        label
    }

    /// Define a label at current offset.
    fn define_label(&mut self, name: &str) {
        self.labels.insert(name.to_string(), self.code.len() as u16);
    }

    /// Emit a byte.
    fn emit(&mut self, byte: u8) {
        self.code.push(byte);
    }

    /// Emit a 16-bit word (little endian).
    fn emit_word(&mut self, word: u16) {
        self.code.push((word & 0xFF) as u8);
        self.code.push((word >> 8) as u8);
    }

    /// Emit a reference to a label.
    fn emit_label_ref(&mut self, name: &str) {
        self.fixups.push((self.code.len(), name.to_string()));
        self.emit_word(0x0000);
    }

    /// Resolve all label references.
    fn resolve_fixups(&mut self) {
        for (offset, name) in &self.fixups {
            if let Some(&addr) = self.labels.get(name) {
                self.code[*offset] = (addr & 0xFF) as u8;
                self.code[*offset + 1] = (addr >> 8) as u8;
            }
        }
    }

    /// Compile a predicate (all clauses with same name/arity).
    fn compile_predicate(&mut self, key: &PredicateKey, clauses: &[&Clause]) {
        if clauses.len() == 1 {
            // Single clause - no choice points needed
            self.compile_clause(clauses[0], None, None);
        } else {
            // Multiple clauses - need TRY/RETRY/TRUST
            let mut labels: Vec<String> = Vec::new();
            for _i in 0..clauses.len() {
                labels.push(self.gen_label(&format!("{}_clause", key.name)));
            }

            for (i, clause) in clauses.iter().enumerate() {
                self.define_label(&labels[i]);

                let next_label = if i + 1 < clauses.len() {
                    Some(labels[i + 1].clone())
                } else {
                    None
                };

                if i == 0 {
                    // First clause: TRY_ME_ELSE
                    if let Some(ref next) = next_label {
                        self.emit(opcodes::TRY_ME);
                        self.emit_label_ref(next);
                    }
                } else if i < clauses.len() - 1 {
                    // Middle clause: RETRY_ME_ELSE
                    if let Some(ref next) = next_label {
                        self.emit(opcodes::RETRY_ME);
                        self.emit_label_ref(next);
                    }
                } else {
                    // Last clause: TRUST_ME
                    self.emit(opcodes::TRUST_ME);
                }

                self.compile_clause(clause, None, None);
            }
        }
    }

    /// Compile a single clause.
    fn compile_clause(
        &mut self,
        clause: &Clause,
        _entry_label: Option<&str>,
        _next_label: Option<&str>,
    ) {
        let analysis = analyze_clause(clause);

        // Allocate environment if needed
        if analysis.permanent_count > 0 {
            self.emit(opcodes::ALLOC);
            self.emit(analysis.permanent_count);
        }

        // Compile head (GET instructions)
        self.compile_head(&clause.head, &analysis);

        // Compile body goals
        for (i, goal) in clause.body.iter().enumerate() {
            let is_last = i == clause.body.len() - 1;
            self.compile_goal(goal, &analysis, is_last);
        }

        // Deallocate and return
        if clause.body.is_empty() {
            // Fact - just proceed
            if analysis.permanent_count > 0 {
                self.emit(opcodes::DEALLOC);
            }
            self.emit(opcodes::PROCEED);
        }
        // For rules, the last goal handles return via EXECUTE
    }

    /// Compile clause head (GET instructions for unification).
    fn compile_head(&mut self, head: &Term, analysis: &ClauseAnalysis) {
        match head {
            Term::Atom(_) => {
                // No arguments to unify
            }
            Term::Compound { args, .. } => {
                for (i, arg) in args.iter().enumerate() {
                    self.compile_get_arg(i as u8, arg, analysis);
                }
            }
            _ => {}
        }
    }

    /// Compile GET instruction for a head argument.
    fn compile_get_arg(&mut self, reg: u8, term: &Term, analysis: &ClauseAnalysis) {
        match term {
            Term::Variable(name) => {
                if let Some(class) = analysis.get_class(name) {
                    match class {
                        VarClass::Permanent(n) => {
                            // First occurrence -> GET_VAR, subsequent -> GET_VAL
                            // For simplicity, always use GET_VAR for now
                            self.emit(opcodes::GET_VAR);
                            self.emit(reg);
                            self.emit(n);
                        }
                        VarClass::Temporary(n) => {
                            self.emit(opcodes::GET_VAR);
                            self.emit(reg);
                            self.emit(n | 0x80); // Mark as temporary
                        }
                    }
                }
            }
            Term::Anonymous => {
                // Skip - anonymous variables don't need to be unified
            }
            Term::Atom(name) => {
                let idx = self.symbols.atoms.lookup(name).unwrap_or(0);
                self.emit(opcodes::GET_ATOM);
                self.emit(reg);
                self.emit_word(idx);
            }
            Term::Integer(n) => {
                self.emit(opcodes::GET_INT);
                self.emit(reg);
                self.emit_word(*n as u16);
            }
            Term::Nil => {
                self.emit(opcodes::GET_NIL);
                self.emit(reg);
            }
            Term::Compound { functor, args } => {
                let functor_idx = self.symbols.atoms.lookup(functor).unwrap_or(0);
                self.emit(opcodes::GET_STR);
                self.emit(reg);
                self.emit_word(functor_idx);
                self.emit(args.len() as u8);

                // Compile UNIFY instructions for structure arguments
                for arg in args {
                    self.compile_unify_arg(arg, analysis);
                }
            }
            Term::Cons(head, tail) => {
                self.emit(opcodes::GET_LIST);
                self.emit(reg);
                self.compile_unify_arg(head, analysis);
                self.compile_unify_arg(tail, analysis);
            }
        }
    }

    /// Compile UNIFY instruction for a structure argument.
    fn compile_unify_arg(&mut self, term: &Term, analysis: &ClauseAnalysis) {
        match term {
            Term::Variable(name) => {
                if let Some(class) = analysis.get_class(name) {
                    match class {
                        VarClass::Permanent(n) => {
                            self.emit(opcodes::UNIFY_VAR);
                            self.emit(n);
                        }
                        VarClass::Temporary(n) => {
                            self.emit(opcodes::UNIFY_VAR);
                            self.emit(n | 0x80);
                        }
                    }
                }
            }
            Term::Anonymous => {
                self.emit(opcodes::UNIFY_VOID);
                self.emit(1);
            }
            Term::Atom(name) => {
                let idx = self.symbols.atoms.lookup(name).unwrap_or(0);
                self.emit(opcodes::UNIFY_ATOM);
                self.emit_word(idx);
            }
            Term::Integer(n) => {
                self.emit(opcodes::UNIFY_INT);
                self.emit_word(*n as u16);
            }
            _ => {
                // Nested structures - simplified handling
                // In full WAM, would emit more complex code
            }
        }
    }

    /// Compile a goal.
    fn compile_goal(&mut self, goal: &Goal, analysis: &ClauseAnalysis, is_last: bool) {
        match goal {
            Goal::Call(term) => {
                self.compile_call(term, analysis, is_last);
            }
            Goal::Is(var, expr) => {
                self.compile_is(var, expr, analysis);
            }
            Goal::Compare(op, left, right) => {
                self.compile_compare(*op, left, right, analysis);
            }
            Goal::Unify(t1, t2) => {
                self.compile_unification(t1, t2, analysis);
            }
            Goal::NotUnify(_, _) => {
                // Not unifiable - simplified implementation
                self.emit(opcodes::FAIL);
            }
            Goal::Cut => {
                self.emit(opcodes::CUT);
            }
            Goal::Write(term) => {
                self.compile_write(term, analysis);
            }
            Goal::Nl => {
                self.emit(opcodes::NL);
            }
            Goal::Fail => {
                self.emit(opcodes::FAIL);
            }
            Goal::True => {
                // Do nothing - always succeeds
            }
        }
    }

    /// Compile a predicate call.
    fn compile_call(&mut self, term: &Term, analysis: &ClauseAnalysis, is_last: bool) {
        // Set up arguments (PUT instructions)
        match term {
            Term::Atom(name) => {
                // Zero-arity predicate
                let _key = PredicateKey::new(name, 0);
                let label = format!("pred_{}_{}", name, 0);

                if is_last && analysis.permanent_count > 0 {
                    self.emit(opcodes::DEALLOC);
                }

                if is_last {
                    self.emit(opcodes::EXEC);
                } else {
                    self.emit(opcodes::CALL);
                }
                self.emit_label_ref(&label);
            }
            Term::Compound { functor, args } => {
                // Set up arguments
                for (i, arg) in args.iter().enumerate() {
                    self.compile_put_arg(i as u8, arg, analysis);
                }

                let label = format!("pred_{}_{}", functor, args.len());

                if is_last && analysis.permanent_count > 0 {
                    self.emit(opcodes::DEALLOC);
                }

                if is_last {
                    self.emit(opcodes::EXEC);
                } else {
                    self.emit(opcodes::CALL);
                }
                self.emit_label_ref(&label);
            }
            Term::Variable(_) => {
                // Meta-call - not supported in simple implementation
                self.emit(opcodes::FAIL);
            }
            _ => {}
        }
    }

    /// Compile PUT instruction for a call argument.
    fn compile_put_arg(&mut self, reg: u8, term: &Term, analysis: &ClauseAnalysis) {
        match term {
            Term::Variable(name) => {
                if let Some(class) = analysis.get_class(name) {
                    match class {
                        VarClass::Permanent(n) => {
                            self.emit(opcodes::PUT_VAL);
                            self.emit(reg);
                            self.emit(n);
                        }
                        VarClass::Temporary(n) => {
                            self.emit(opcodes::PUT_VAL);
                            self.emit(reg);
                            self.emit(n | 0x80);
                        }
                    }
                }
            }
            Term::Anonymous => {
                self.emit(opcodes::PUT_VAR);
                self.emit(reg);
                self.emit(0xFF); // Void
            }
            Term::Atom(name) => {
                let idx = self.symbols.atoms.lookup(name).unwrap_or(0);
                self.emit(opcodes::PUT_ATOM);
                self.emit(reg);
                self.emit_word(idx);
            }
            Term::Integer(n) => {
                self.emit(opcodes::PUT_INT);
                self.emit(reg);
                self.emit_word(*n as u16);
            }
            Term::Nil => {
                self.emit(opcodes::PUT_NIL);
                self.emit(reg);
            }
            Term::Compound { functor, args } => {
                let functor_idx = self.symbols.atoms.lookup(functor).unwrap_or(0);
                self.emit(opcodes::PUT_STR);
                self.emit(reg);
                self.emit_word(functor_idx);
                self.emit(args.len() as u8);
                // Would need to emit structure building code
            }
            Term::Cons(_, _) => {
                self.emit(opcodes::PUT_LIST);
                self.emit(reg);
                // Would need to emit list building code
            }
        }
    }

    /// Compile arithmetic evaluation (X is Expr).
    fn compile_is(&mut self, var: &str, expr: &ArithExpr, analysis: &ClauseAnalysis) {
        // Simplified: just emit IS opcode with variable reference
        if let Some(class) = analysis.get_class(var) {
            let var_idx = match class {
                VarClass::Permanent(n) => n,
                VarClass::Temporary(n) => n | 0x80,
            };
            self.emit(opcodes::IS);
            self.emit(var_idx);
            // Would need to compile expression
            self.compile_arith_expr(expr, analysis);
        }
    }

    /// Compile arithmetic expression.
    fn compile_arith_expr(&mut self, expr: &ArithExpr, analysis: &ClauseAnalysis) {
        // Simplified: expressions would be compiled to stack-based bytecode
        // For now, just a placeholder
        match expr {
            ArithExpr::Integer(n) => {
                self.emit_word(*n as u16);
            }
            ArithExpr::Variable(name) => {
                if let Some(class) = analysis.get_class(name) {
                    let idx = match class {
                        VarClass::Permanent(n) => n,
                        VarClass::Temporary(n) => n | 0x80,
                    };
                    self.emit(idx);
                }
            }
            ArithExpr::BinOp(op, _, _) => {
                // Would compile left, right, then operation
                let _op_byte = match op {
                    ArithOp::Add => 0x01,
                    ArithOp::Sub => 0x02,
                    ArithOp::Mul => 0x03,
                    ArithOp::Div => 0x04,
                    ArithOp::Mod => 0x05,
                };
            }
            ArithExpr::Neg(_) => {}
        }
    }

    /// Compile comparison.
    fn compile_compare(
        &mut self,
        op: CompareOp,
        _left: &ArithExpr,
        _right: &ArithExpr,
        _analysis: &ClauseAnalysis,
    ) {
        let opcode = match op {
            CompareOp::Lt => opcodes::CMP_LT,
            CompareOp::Gt => opcodes::CMP_GT,
            CompareOp::Le => opcodes::CMP_LE,
            CompareOp::Ge => opcodes::CMP_GE,
            CompareOp::ArithEq => opcodes::CMP_EQ,
            CompareOp::ArithNe => opcodes::CMP_NE,
        };
        self.emit(opcode);
        // Would compile expressions
    }

    /// Compile unification goal.
    fn compile_unification(&mut self, _t1: &Term, _t2: &Term, _analysis: &ClauseAnalysis) {
        // Would emit code to unify two terms
        // Simplified for now
    }

    /// Compile write goal.
    fn compile_write(&mut self, term: &Term, _analysis: &ClauseAnalysis) {
        match term {
            Term::Atom(name) => {
                let idx = self.symbols.atoms.lookup(name).unwrap_or(0);
                self.emit(opcodes::WRITE_ATOM);
                self.emit_word(idx);
            }
            Term::Integer(n) => {
                self.emit(opcodes::WRITE_INT);
                self.emit_word(*n as u16);
            }
            _ => {
                self.emit(opcodes::WRITE);
                self.emit(0); // Register 0
            }
        }
    }

    /// Compile query.
    fn compile_query(&mut self, goals: &[Goal]) {
        // Create a dummy analysis for the query
        let analysis = ClauseAnalysis {
            var_classes: HashMap::new(),
            permanent_count: 0,
            temporary_count: 0,
            head_vars: Vec::new(),
            goal_vars: Vec::new(),
        };

        for (i, goal) in goals.iter().enumerate() {
            let is_last = i == goals.len() - 1;
            self.compile_goal(goal, &analysis, is_last);
        }

        // End with HALT
        self.emit(opcodes::HALT);
    }
}

/// Compile a program to bytecode.
pub fn compile_program(program: &Program) -> CompiledProgram {
    let symbols = SymbolTable::from_program(program);
    let compiler = Compiler::new(symbols);
    compiler.compile(program)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parse;

    #[test]
    fn test_compile_simple_fact() {
        let program = parse("parent(tom, bob).").unwrap();
        let compiled = compile_program(&program);

        assert!(!compiled.code.is_empty());
        assert!(compiled.predicates.contains_key(&PredicateKey::new("parent", 2)));
    }

    #[test]
    fn test_compile_query() {
        let program = parse("foo. ?- foo.").unwrap();
        let compiled = compile_program(&program);

        assert!(compiled.query_offset.is_some());
    }

    #[test]
    fn test_compile_multiple_clauses() {
        let program = parse(
            "
            parent(tom, bob).
            parent(bob, pat).
        ",
        )
        .unwrap();
        let compiled = compile_program(&program);

        // Should have TRY_ME/TRUST_ME for multiple clauses
        assert!(compiled.code.contains(&opcodes::TRY_ME));
        assert!(compiled.code.contains(&opcodes::TRUST_ME));
    }
}
